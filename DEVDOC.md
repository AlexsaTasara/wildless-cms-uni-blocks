Файл содержит информацию, полезную разработчикам новых унифицированных блоков.

# Качество кода

1. Что не имеет собственного имени - не существует.

   При декомпозиции следует избегать слишком общих или дублирующих имён. Каждая выносимая сущность должна определяться по смыслу и получать соответствующее название. Не по принадлежности к категории или другой сущности, а по сути самой выносимой сущности.

1. Следует избегать вложенных тернарников.

   Вложенные условия можно выносить в константы или отдельные функции. В отдельных случаях можно прибегать к предусловиям для "разгрузки" первых уровней вложенности. Для оформления предусловий часто приходится прибегать к логической инверсии. Тогда полезная следующая теорема:

   ```
   !(A | B) = !A & !B
   !(A & B) = !A | !B
   ```

1. Позитивные условия сначала

   Bad

   ```tsx
   role={!href ? 'button' : 'link'}
   ```

   Good

   ```tsx
   role={href ? 'link' : 'button'}
   ```

1. Строки со сложной интерполяцией через массив с последующим `join(' ')`

   Bad

   ```ts
   const style = `flex items-center justify-center
     ${withoutText ? 'h-12 w-12' : `px-8 gap-2 ${aboveText ? 'py-2' : 'py-3.5'}`} ${
     rounded ? 'rounded-full' : ''
   }`;
   ```

   Good

   ```ts
   const style = [
     'flex items-center justify-center',
     isWithText(props) ? withTextStyle : 'h-12 w-12',
     rounded ? 'rounded-full' : '',
   ].join(' ');
   ```

# Стили

## Размер common.css

### Использование классов

- Не использовать классы `space-...`, обходиться `margin` и `gap`
- Минимизировать использование `grid-cols-...`
- Минимизировать использование псевдоэлементов
- Минимизировать использование `transition`

### Унификация

Все

- отступы
- высоты
- ширины
- скругления
- ховеры
- границы
  элементов должны быть унифицированы, расхождения обсудить с дизайнерами

### Пересечение с зарезервированными именами

При сборке tailwind проверяет исходный код на наличие совпадений с зарезервированными именами атомов. Таким образом возможно пересечение с зарезервироваными словами JS (например filter - array.filter) или с именами переменных. В случае с filter, данный атом будет отключен через конфиг tailwind

Это необходимо учитывать при создании переменных.

# Чек-листы

## Вёрстка блока

- Вынести декларацию типа контента блока `<block_name>Content` в отдельный файл `<block_name>Content.ts` в соответствии с требованиями в тикете
- PixelPerfect по дизайнам
  [Расширение для Chromium-браузеров](https://chrome.google.com/webstore/detail/perfectpixel-by-welldonec/dkaagdgjmgdmbnecmcefdhjekcoceebi?hl=ru)
  [Как извлечь слой из Figma](https://www.captain-design.com/blog/how-to-export-images-in-figma/)
- Добавить fixture-файл рядом с кодом блока с именем `<block_name>.fixture.ts`
- Проверка внешнего вида на всех согласованных расширениях (используем cosmos `npm run cosmos`)
- Проверка переходов между расширениями

Если всё в порядке:

- Добавить новый блок [сюда](./src/Blocks.ts)
- Добавить тип контента блока [сюда](./src/BlockContent.ts)
- Добавить новый блок в соответствии с его схемой [сюда](./src/ContentPage.page.json)
- Проверить, что интерфейс Content (то, что будет заполнять оператор) отделён от интерфейса прочих props
- Внести интерфейс Сontent в юнион тип [тут](./src/Blocks.ts)
